import { DatabaseTypes, QueryResult } from '@bahasa-ai/engine-database'
import { Zendesk } from '@bahasa-ai/plugins-iris'
import axios from 'axios'
import moment from 'moment-timezone'

import { ClosedByAgentTag, ClosedByBotTag, MelebihiLimitPendingTag } from '../Util/CSHelper'
import { getUrlFileName } from '../Util/CSHelper'

export type ZendeskSatisfactionScoreType = 'unoffered' | 'offered' | 'received' | 'received_with_comment' | 'received_without_comment' | 'good' | 'good_with_comment' | 'good_without_comment' | 'bad' | 'bad_with_comment' | 'bad_without_comment'

export type CreateTicketType = {
  integration: string,
  sourceId: string,
  user: { name: string },
  tags?: string[],
  zendeskRequesterId?: number
}

type ZendeskAuthScopesTypes = 'read' | 'write' | 'impersonate'

type ZendeskBase = {
  error?: string,
  message?: string
}

type ZendeskCreateTokenType = ZendeskBase & {
  token: {
    url: string,
    id: number,
    user_id: number,
    client_id: number,
    token: string,
    refresh_token?: string,
    created_at: string,
    expires_at?: string,
    used_at?: string,
    scopes: ZendeskAuthScopesTypes,
    full_token: string
  }
}

type ZendeskSatisfactionType = ZendeskBase & {
  url: string,
  id: number,
  assignee_id: number,
  group_id: number,
  requester_id: number,
  ticket_id: number,
  score: ZendeskSatisfactionScoreType,
  created_at: Date,
  updated_at: Date,
  comment?: string
}

export type CommentTicketParam = {
  messageId: string,
  query: string,
  media?: {
    url: string,
    caption: string
  },
  publishedAt: Date
}

export class ZendeskService {
  private static instance: ZendeskService

  private zendesk: Zendesk
  private zendeskUrl: string
  private zendeskAuth: string
  private zendeskOauthAccessToken: string = null
  private zendeskOauthClientId: number

  constructor(zendeskUrl: string, auth: string, oauthClientId: number) {
    this.zendesk = new Zendesk(zendeskUrl, auth, { retryAfter: false })
    this.zendeskAuth = auth
    this.zendeskUrl = zendeskUrl
    this.zendeskOauthClientId = oauthClientId
  }

  static getInstance() {
    if (!this.instance) {
      const oauthClientId = process.env.ZENDESK_OAUTH_CLIENT_ID ? parseInt(process.env.ZENDESK_OAUTH_CLIENT_ID) : new Error('ZENDESK_OAUTH_CLIENT_ID is not exist on env')

      if (typeof oauthClientId === 'object') {
        throw oauthClientId
      }

      this.instance = new ZendeskService(`${process.env.ZENDESK_URL}`, `Basic ${process.env.ZENDESK_AUTH}`, oauthClientId)
    }

    return this.instance
  }

  async createTicket(param: CreateTicketType) {
    const subject = `WA - ${param.sourceId} - ${param.user.name}`
    const requester = {
      name: param.user.name,
      phone: param.sourceId
    }

    const commentBody = `Permintaan baru dari ${param.user.name} - ${param.sourceId}`
    const reportRequest = await this.zendesk.createTicket({
      subject: subject,
      tags: param.tags,
      comment: {
        body: commentBody,
        plain_body: commentBody,
        html_body: `<div style="background-color: #FFF6D9; border: 1px solid #EFDAA3; padding: 12px 16px 14px; margin-bottom: 16px; border-radius: 3px; color: #2F3941;">${commentBody}</div>`,
        // uploads: [upload.token]
      },
      can_be_solved_by_me: true,
      type: 'question',
      status: 'new',
      ...param.zendeskRequesterId ? { requester_id: param.zendeskRequesterId } : { requester }
    })

    return reportRequest
  }

  async getAllFields() {
    return this.zendesk.getAllField()
  }

  async getTicketFieldField(id: number) {
    return this.zendesk.getTicketField(id)
  }

  async commentTicket(user: QueryResult<DatabaseTypes.User>, messages: CommentTicketParam[], sentBy: 'user' | 'bot' = 'user') {
    const ticketID: number = user.userData.zendeskTicketId

    const tokenUpload: string[] = []
    const finalMessages: string[] = []
    for (const message of messages) {
      let finalMessage = ''
      if (messages.length > 1) {
        finalMessage += `[${moment(message.publishedAt).tz('Asia/Jakarta').format('HH:mm')}] `
      }

      if (message.media) {
        const filename = getUrlFileName(message.media.url)
        try {
          const attachment = await this.zendesk.uploadFileFromURL(filename, message.media.url)
          tokenUpload.push(attachment.data.upload.token)

          finalMessage += `${message.media.caption} (${filename})`

          finalMessages.push(finalMessage)
        } catch (error) {
          finalMessage += `${message.media.caption} (${filename} - Upload failed - ${error.message})`
          finalMessages.push(finalMessage)
        }
      } else {
        finalMessage += message.query
        finalMessages.push(finalMessage)
      }
    }

    return await this.zendesk.updateTicket(ticketID, {
      comment: {
        type: 'byUser',
        body: finalMessages.join('\n'),
        author_id: sentBy === 'user' ? user.userData.requesterId : parseInt(process.env.ZENDESK_BOT_AUTHOR_ID),
        uploads: tokenUpload
      },
      status: 'open'
    })
  }

  async cancelTicketByUser(user: QueryResult<DatabaseTypes.User>, tags: string[]) {
    const ticketID: number = user.userData.zendeskTicketId

    const commentBody = [
      'Customer telah membatalkan tiket sehingga percakapan ini diakhiri.',
      'Status tiket telah diubah menjaidi closed dan agent tidak dapat membalas kembali.',
      'Customer telah kembali terhubung dengan chatbot.'
    ].join('\n')

    return await this.zendesk.updateTicket(ticketID, {
      status: 'closed',
      comment: {
        body: commentBody,
        author_id: user.userData.requesterId,
        plain_body: commentBody,
        html_body: `<div>${commentBody}</div>`,
        public: false
      },
      tags: [...tags, ClosedByBotTag]
    })
  }

  async ticketAutoClose(user: QueryResult<DatabaseTypes.User>, tags: string[]) {
    const ticketID: number = user.userData.zendeskTicketId

    const commentBody = [
      'Percakapan telah diakhiri secara otomatis karena customer tidak membalas dalam 20 menit.',
      'Status tiket telah diubah menjadi closed dan agent tidak dapat membalas kembali.',
      'Customer telah kembali terhubung dengan chatbot.'
    ].join('\n')

    return await this.zendesk.updateTicket(ticketID, {
      status: 'closed',
      comment: {
        body: commentBody,
        author_id: user.userData.requesterId,
        plain_body: commentBody,
        html_body: `<div>${commentBody}</div>`,
        public: false
      },
      tags: [...tags, ClosedByBotTag, MelebihiLimitPendingTag]
    })
  }

  async updateTagSolvedByAgent(user: QueryResult<DatabaseTypes.User>, tags: string[]) {
    const ticketID: number = user.userData.zendeskTicketId

    return await this.zendesk.updateTicket(ticketID, {
      tags: [...tags, ClosedByAgentTag]
    })
  }

  /**
   * See https://developer.zendesk.com/rest_api/docs/support/oauth_tokens#create-token
   * Get Zendesk Oauth Access Token, only need once if the token is long lived
   */
  async getZendeskOauthAccessToken() {
    const headers = {
      Authorization: this.zendeskAuth
    }

    // @TODO: CACHE!

    const authenticate = await axios.post<ZendeskCreateTokenType>(`${this.zendeskUrl}/oauth/tokens.json`, {
      token: {
        client_id: this.zendeskOauthClientId,
        scopes: [
          'impersonate',
          'write'
        ]
      }
    }, {
      headers: headers
    })

    if (authenticate.status >= 200 && authenticate.status < 300) {
      this.zendeskOauthAccessToken = authenticate.data.token.full_token
      return true
    } else {
      console.log(`ZENDESK REQUEST ${authenticate.status}: %j`, authenticate.data)
      throw new Error(`ZENDESK Error: ${authenticate.data.error}`)
    }
  }

  /**
   * See https://develop.zendesk.com/hc/en-us/articles/360001068647-Making-API-requests-on-behalf-of-end-users-Zendesk-Support-#token
   * Need zendesk oauth access token with impersonate scope to update CSAT
   */
  public async updateTicketCSAT(ticketId: number, userId: number, satisfactionScore: ZendeskSatisfactionScoreType, comment?: string) {
    if (!this.zendeskOauthAccessToken) {
      // not truthy! request... access token
      await this.getZendeskOauthAccessToken()
    }

    console.log('TicketId: ', ticketId)

    return await axios.post<ZendeskSatisfactionType>(`${this.zendeskUrl}/tickets/${ticketId}/satisfaction_rating`, {
      satisfaction_rating: {
        score: satisfactionScore,
        comment: comment
      }
    }, {
      headers: {
        Authorization: `Bearer ${this.zendeskOauthAccessToken}`,
        'X-On-Behalf-Of': userId
      }
    })
  }

  // close session chatbot ticket
  async closeSessionChatbotTicket(ticketId: number, tags: string[]) {
    return await this.zendesk.updateTicket(ticketId, {
      status: 'solved',
      tags
    })
  }
}